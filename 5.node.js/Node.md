---
typora-root-url: media
typora-copy-images-to: media

---

# 一、Node开发概述

## 1. Node开发概述

### 1.1 为什么要学习服务器端开发基础

- 能够和后端程序员更加紧密的配合
- 网站业务逻辑前置，学习前端技术需要后端技术支撑（Ajax）
- 扩宽知识视野，能够站在更高的角度审视整个项目

### 1.2 服务器开发要做的事情

- 实现网站的业务逻辑
- 数据的增删改查

### 1.3 为什么选择Node

- 使用 JavaScript语法开发后端应用
- 一些公司要求前端工程师掌握
- Node开发生态系统活跃，有大量开源库可以使用
- 前端开发工具大多基于Node开发

### 1.4 Node是什么

Node是一个基于Chrome V8 引擎的JavaScript**代码运行环境**

**代码运行环境：**浏览器和Node等能够运行JavaScript代码的软件就是JavaScript代码的运行环境。





## 2. Node运行环境搭建

### 2.1 Node运行环境安装

官网：https://nodejs.org/en/

两个版本

LTS=：Long Term Support长期支持版稳定版

Current：拥有最新特性实验版

![image-20200511175223412](/image-20200511175223412.png)

![image-20200511180948704](/image-20200511180948704.png)

输入node -v返回版本说明安装成功







## 3. Node.js快速入门

### 3.1  Node.js的组成

Node.js是由**ECMAScript** 和 **Node环境提供的一些附加API**组成的，包括网络、文件、路径的一些更加强大的API。（如读取硬盘里的内容、获取操作系统的信息等）

![image-20200511181543810](/image-20200511181543810.png)



### 3.2 Node.js的基础语法

所有的ECMAScript语法在Node中都可以使用

![image-20200511182920562](/image-20200511182920562.png)

利用shell调用js文件成功



### 3.3 Node. js全局对象 global

在浏览器中全局对象是 window，在Node中全局对象是global 

Node中全局对象下有以下方法，可以在任何地方使用， global可以省略。
console. log()在控制台中输出

- setTimeout（)设置超时定时器
- clearTimeout()清除超时时定时器
- setInterval()设置间歇定时器
- clearInterval()清除间歇定时器



# 二、Node.js模块化开发

## 1.Node.js模块化开发

### 1.1JavaScript开发弊端

JavaScript存在两大弊端，**文件依赖**和**命名冲突**

![image-20200511204518526](/image-20200511204518526.png)

文件和文件之间是完全开放的，会导致前一个文件声明的变量如果在后面的文件中再次声明，会改变前一个文件的值。



### 1.2软件中的模块化开发

把一个功能当做一个模块，多个模块一起组成完整的应用，**单独的抽离一个模块不会影响到其他功能的运行**。

就像电脑一样，由显卡、cpu等组成，各自有各自的功能。

![image-20200511205111720](/image-20200511205111720.png)



### 1.3 Node. js中模块化开发规范

Node. js规定**—个JavaScript文件就是一个模块**，模块**内部定义的变量和函数****默认情况下在**外部无法得到**

#### 模块导入和导出方法

模块内部可以使用 **exports对象进行成员导岀**，使用 **require方法导入其他模块**。

![image-20200511210517343](/image-20200511210517343.png)



### 1.4模块成员导出代码示例

- a模块

`// 在a模块中声明一个函数`

`const sum = (*n1*, *n2*) => *n1* + *n2*;`

`*// 导出a模块的sum方法*`

`exports.sum = sum;`

- b模块

`// 在b模块中导入a模块`

`*// const a = require('./02.a.js');*`

`*// 模块导入时，后缀的.js可以省略*`

`const a = require('./02.a');`

`console.log(a);`

`console.log(a.sum(10, 20));`

![image-20200511211713641](/image-20200511211713641.png)





### 1.5模块成员导出的另一种方法

`module exports. version = version`

`module exports. sayHi  = sayHi`



### 1.6两种模块导出方法的区别

- exports是module.exports的别名（地址引用关系），导**出对象最终以module.exports为准**

当两个对象指向不同的对象时，以module.exports为准

![image-20200511214411733](/image-20200511214411733.png)

**代码验证**

- 第一个文件中给module.exports 重新赋值

`const greeting = *name* => `hello ${*name*}`;`

`const x = 100;`

`exports.x = x;`

`module.exports.greeting = greeting;`

`// 当exports对象和moudle.exports对象指向的不是同一个对象时 以module.exports为准`

`module.exports = {`

  `name: 'zhangsan'`

`}`

`exports = {`

  `age: 20`

`}`



- 第二个文件中输出导入的对象

`const a = require('./04.module.exports.js');`

`*// console.log(a.greeting('zhangsan'));*`

`console.log(a);`



- 结果以module.exports 为准

![image-20200511215431802](/image-20200511215431802.png)





## 2.系统模块

### 2.1什么是系统模块

- **Node运行环境提供的API就是系统模块**

因为这些API都是以模块化方式开发的，所以我们又称ode运行环境提供的API为系统模块



### 2.2 fs（file system）文件操作 系统模块

要使用fs系统模块，必须先导入

语法：  

 `const fs = require('fs');`



fs系统模块中有很多方法

#### 2.2.1读取文件内容

语法：

`fs. reaFile('文件路径/文件名称'[,'文件编码]，callback);`



**读取文件示例**

`// 导入fs系统模块`

`const fs = require('fs');`

`// 读取helloworld.js文件`

`//这里写utf8和utf-8都可以`

`fs.readFile('01.helloworld.js', 'utf-8', (err, doc) => {`

​	`//  文件读取正确，err是null`

​	 `//  文件读取错误，err是一个对象，包含了错误信息`

  	`console.log(err);`

 	 `console.log(doc);`

  	`//if (err == null) {`

​     `//	 console.log(doc);`

 	`// }`

`});`



**执行结果**

![image-20200512163817045](/image-20200512163817045.png)



#### 2.2.2写入文件内容

语法：

`fs.writeFile('文件路径/文件名称','数据',callback);`

当执行一段代码时，可以将bug信息写入文件。



**代码示例**

`const fs = require('fs');`

`fs.writeFile('deom.text', '将要写入的内容', err => {`

 	 `if (err != null) {`

​    	`console.log(err);`

​    	`return;`

 	 `}`

  	`console.log('文件写入成功');`

`})`



**注意**：文件写入会覆盖掉之前的内容



### 2.3系统模块path路径操作

#### 2.3.1为什么要进行路径拼接

不同的操作系统路径操作符不统一，windows中/和\都可以，linux中只能/

#### 2.3.2路径拼接语法

`path.join('路径','路径',...)`



**代码示例**

`const path = require('path');`

`const finalPath = path.join('public','upload','avatar');`



在Windows系统中返回public\upload\avatar



#### 2.3.3相对路径和绝对路径

- 在读写文件时，**大多数情况需要使用绝对路径，**原因是有时候相对路径是相对命令行当前的工作路径

**如何将相对路径转换为绝对路径**（路径拼接）

使用_dirname 来获取当前文件所在的绝对路径

使用_dirname 来获取当前文件所在的绝对路径

`path(_dirname,'01.helloworld.js')`





## 3.第三方模块

### 3.1什么是第三方模块

別人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。

**第三方模块的两种存在形式**：

1.以js文件的形式存在，提供实现项目具体功能的API接口

2.以命令行工具形式存在，辅助项目开发



### 3.2获取第三方模块

- npmjs.com：第三方模块的存储和分发仓库

![image-20200512183009561](/image-20200512183009561.png)



- **npm(node package manager):node的第三方管理工具**

它其实也是一个第三方模块，只是下载node的时候就已经一起下载了，可以通过它来下载其他的第三方模块

**下载**：npm install 模块名称

**卸载**：npm uninstall 模块名称



- **全局安装和本地安装**

全局安装时安装到公共目录中，所有项目都可以使用该模块

本地安装安装到该目录下，只有该项目能使用

一般**库文件使用本地安装**，**命令行工具用全局安装**



### 3.3第三方模块nodemon

nodemon是一个命令行工具，用于辅助项目开发。

其主要作用是，在命令行执行某文件之后，如果对改文件进行修改，会再次**自动执行该文件**。

使用步骤

1.npm install nodemon -g 下载

2.在命令行工具中，用nodemon命令来代替node命令



### 3.4第三方模块 nrm

nrm（ npm registry manager）：npm下载地址切换工具



**使用步骤**

1.使用 npm install nrm-g下载它
2.查询可用下载地址列表nrm ls
3.切换npm下载地址 nrm use下载地址名称

![image-20200512214953464](/image-20200512214953464.png)



### 3.5第三方模块Gulp

是一个基于node平台开发的前端构建工具。

把机械化的操作编写成任务，在执行机械化操作时，只需要执行一个命令行命令就行了，**简单来说就是用来打包项目的**。



#### 3.5.1Gulp能做什么

- 项目上线，将HTML、CSS、S文件压缩合并
- 语法转换（es6、less…）
- 公共文件抽离（比如抽取公共文件的头部，在头部需要维护时，只更改头部文件就行了）
- 修改文件后，浏览器自动新



#### 3.5.2Gulp使用步骤

1.使用 npm install gulp下载gulp库文件

2.在项目根目录下建立 gulpfile.js文件

3.重构项目的文件夹结构，src目录放置源代码文件，dist目录放置构建后文件

4.在 gulpfile.js文件中编写任务

5.在命令行工具中执行gulp任务



#### 3.5.3gulp中的方法

- **gulp.src():获取任务主要处理的文件**

`gulp.src('文件路径');`

- **gulp.dest():输出文件**

`gulp.dest('文件要输出的路径');`

- **gulp.task():建立gulp任务**

语法：

`gulp.task('要建立任务的名称',()=>{`

​	`...`

`})`

- **gulp.watch.():监控文件的变化**



![image-20200513211849080](/image-20200513211849080.png)

在命令行工具中，下载gulp-cli 就可以在命令行工具中用gulp命令运行任务了

![image-20200513211503611](/image-20200513211503611.png)



##### 运行任务时报错的两种解决方法

![image-20200513212732809](/image-20200513212732809.png)

![image-20200513212800880](/image-20200513212800880.png)





#### 3.5.4Gulp中的插件

Gulp模块中的方法太少了，如果需要压缩代码等操作，需要用到Gulp插件



- gulp-htmlmin:htm文件压缩
- gulp-csso：压缩CSS 
- gulp- babel:Javascrip语法转化

![image-20200514152852255](/image-20200514152852255.png)

- gulp-less:less语法转化
- gulp-uglify：压缩混淆 JavaScript
- gup-file-include公共文件包含
- browsersync浏览器实时同步



**先下载后使用**

如npm install gulp-htmlmin

![image-20200513213658107](/image-20200513213658107.png)

在官网上查找插件的使用方法



##### 两个小技巧

1. *html选取所有html文件

以此类推

![image-20200513220750285](/image-20200513220750285.png)



2. 在html文档中引入公共部分

![image-20200513215641830](/image-20200513215641830.png)



##### 注意

在使用gulp依次执行任务时，不能再用

`gulp.task('default',['htmlmin','cssmin]','jsmin','copy']);`

的方法了，要用下面这种方法，参考下图

`gulp.task('default', gulp.series('htmlmin', 'cssmin', 'jsmin', 'copy', *done* => {`

  `done();`

`}));`

![image-20200514154401377](/image-20200514154401377.png)





## 4.package.json文件

### 4.1node_modules文件问题

package.json这个文件是为了解决node_modules文件过碎的问题，文件过碎会导致传输太慢

有了**package.json**这个文件，在传输项目的时候就不用再传输**node_modules**这个文件了



**使用方法**

`npm init -y`

![image-20200514181022351](/image-20200514181022351.png)

![image-20200514181242896](/image-20200514181242896.png)

生成package.json文件，在项目传输完成后，在控制台中输入

`npm install`

就会自动下载需要的模块



### 4.2项目依赖和开发依赖

**项目依赖**：在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖

- 使用 npm install包名命令下载的文件会**默认被添加到 package.json文件的 dependencies字段中**

如jQuery模块



**开发依赖**：在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖

- 使用 **npm install包名 --save-dev**命令将包添加到 package. json文件的 **devDependencies**字段中

如gulp

![image-20200514175309735](/image-20200514175309735.png)



**注意**：当我们开发过程中，需要所有的模块时，用`npm install`来下载**package.json**文件中记录的所有模块，当项目上线运行，用`npm install --production`下载**开发依赖**



### 4.3package-lock.json文件的作用

- 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题

- 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作





## 5.node.js中模块的加载机制

### 5.1当模块拥有路径但是没有后缀时

`require('./find.js')`

`require('./find')`

1.require方法根据模块路径査找模块，如果是完整路径，直接引入模块

2.如果模块后缀省略，先找同名JS文件再找同名JS文件夹

3.如果找到了同名文件夹，找文件夹中的 index. js

4.如果文件夹中没有 Index.js就会去当前文件夹中的 package. json文件中查找main选项中的入囗文件

![image-20200514183317280](/image-20200514183317280.png)

5.如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到



### 5.2当模块没有路径且没有后缀时

`require('find');`

1. Node.js会假设它是系统模块
2. Node.js会去 node _modules文件夹中
3. 首先看是否有该名字的JS文件
4. 再看是否有该名字的文件夹
5. 如果是文件夹看里面是否有 index. js
6. 如果没有 index js查看该文件夹中的 package. json中的main选项确定模块入口文件
7. 否则找不到报错





# 三、服务器端

## 1.服务器端基础概念

### 1.1网站的组成

网站应用程序主要分为两大部分：**客户端**和**服务器端**

**客户端**：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、 JavaScript构建

**服务器端**：在服务器中运行的部分，负责存储数据和处理应用逻辑

![image-20200514200307513](/image-20200514200307513.png)



### 1.2Node网站服务器

能够**提供网站访问服务**的**机器**就是网站服务器，它能够接收客户端的**请求**，能够对请求做出**响应**。



### 1.3IP地址

IP地址是互联网中设备的**唯一标识**。

IP是Internet protocol address 的简写，代表互联网协议地址。



### 1.4域名

由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时**上网所使用的网址**。

http://www.itheima.com => http://124.165.219.100/

虽然在地址栏中输入的是网址但是最终还是会**将域名转换为IP才能访问到指定的网站服务器**



### 1.5端口

端口是计算机与外界交流的出口，用来区分服务器在电脑中**提供不同的服务**。（就像食堂窗口一样，不同的窗口提供不同的食物）**本质是一堆数字**。

![image-20200514201813842](/image-20200514201813842.png)



### 1.6URL

**统一资源定位符**，又叫URL（ Uniform resource locator），是专为标识 Internet网上资源位置而设的-种编址方式，我们平时所说的网页地址指的即是∪RL

![image-20200514202332535](/image-20200514202332535.png)



### 1.7开发过程中的客户端和服务器端

开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑，既是客户端，也是服务器端。

**客户端--浏览器**

**服务器端--Node**



所有的电脑都有：

本机域名：localhost

本地IP：127.0.0.1





## 2.创建web服务器

方法如下：

![image-20200514213842847](/image-20200514213842847.png)

然后在浏览器中用

`localhost：端口`

来访问端口

![image-20200514213950631](/image-20200514213950631.png)



## 3.HTTP协议

### 3.1HTTP协议的概念

**超文本传输协议**（Hyper Text Transfer Protocol,缩写HTTP)，规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端和服务器**请求和应答（响应）标准。**

![image-20200514214458663](/image-20200514214458663.png)



### 3.2报文

在HTTP**请求和响应的过程中传递的数据**就叫报文，包括要传送的数据和一些附加信息，并且要准守规定好的格式。分为**请求报文**和**响应报文**。

报文是**冒号分割的键值对**。

### 3.3请求报文

![image-20200514214738514](/image-20200514214738514.png)

#### 3.3.1请求方式（Request Method）

`res.method`方法

两个值

​	**GET   请求数据**

​	**POST   发送数据**

可以根据不同的请求响应不同的数据

![image-20200514220845559](/image-20200514220845559.png)



#### 3.3.2请求地址（Request URL）

​	`req.headers`获取请求报文

​	`req.headers['想要获取的属性'] `获取请求报文中的属性

​	`req.url`获取请求地址

![image-20200514222213975](/image-20200514222213975.png)



### 3.4响应报文

![image-20200514214800766](/image-20200514214800766.png)



#### 3.4.1HTTP状态码

- 200请求成功
- 404请求的资源没有找到
- 500服务器端错误
- 400客户端请求语法错误



#### 3.4.2内容类型

- text/html 
- text/css 
- application/javascript 
- image/jpeg 
- application/json



`res.writeHead(第一个参数就是状态码,{`

`})`

用这个方法可以返回不同的状态码，第二个参数是一个对象，可以返回文本的类型，**默认纯文本**

**示例**

![image-20200514223326926](/image-20200514223326926.png)

#### 注意：

如果请求的文件有很多外链文件，没有办法写固定的文本类型，**就需要用到mine模块**

mine模块中有个getType方法可以根据路径返回内容类型

mine.getType('文件路径')



## 4.HTTP请求与响应处理

### 4.1请求参数

客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作，表单操作。



### 4.2GET请求参数

![image-20200514224644422](/image-20200514224644422.png)

![image-20200514224409282](/image-20200514224409282.png)

用url的parse方法可以吧字符串转换为对象



### 4.3POST请求参数

- 参数被放置在请求体中进行传输
- POST参数是通过事件的方式接收的，需要data事件和end事件
- 使用querystring系统模块的方法parse可以将参数转换为对象

![image-20200515161421062](/image-20200515161421062.png)

​	![image-20200515163753490](/image-20200515163753490.png)



### 4.4路由

用户输入index响应index网页，输入login响应login网页，这就是路由。

**路由**是指客户端请求地址与服务器端程序代码的对应关系。简单的说就是，请求什么响应什么。

**其实就是根据用户的url地址中的pathname的值，来返回相应的内容**



### 4.5静态资源

服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、 JavaScript、 Image文件

**代码示例**

![image-20200515180912586](/image-20200515180912586.png)



### 4.6动态资源

**相同的请求地址，传递不同的请求参数，得到不同的响应资源，这种资源就是动态资源**

![image-20200515170140345](/image-20200515170140345.png)





## 5.Node.js异步编程

### 5.1同步API，异步API

同步API：只有当前API执行完成后，才能继续执行下一个API

代码示例：

`console.log('before');`

`console.log('after');`



异步API：当前API的执行不会阻塞后续代码的执行

代码示例:

`cosole.log('before');`

`setTimeout(`

​	`()=>{`

​		`cosole.log('last');`

​	`},2000);`

`console.log('after');`



**和JS的同步、异步概念一样**



### 5.2同步API和异步API的区别

- 同步API可以从返回值里拿到API的执行结果，异步API不可以

- 同步API从上往下执行，会堵塞下面的代码。异步API不会



### 5.3回调函数

自己定义函数让别人去调用，可以解决异步API拿不到API执行结果的问题。



### 5.4代码执行顺序

![image-20200516183122792](/image-20200516183122792.png)

![image-20200516183328489](/image-20200516183328489.png)



### 5.5Node.js中的异步API

有回调函数的都是异步API



### 5.6Promise

Promise出现的目的是解决Node.js异步编程中**回调地狱**的问题

**回调地狱**：异步编程中出现的回调函数嵌套回调函数过多的情况

**promise实际上是一个构造函数**，**可以链式编程**

![image-20200516215958184](/image-20200516215958184.png)

用then 方法返回resolve执行结果，用catch方法返回reject执行结果



### 5.7异步函数

异步函数是**异步编程语法的终极解决方案**，它可以让我们**将异步代码写成同步的形式**，让代码不再有回调函数嵌套，使代码变得清晰明了



语法：

`const fn = async  () => {};`

或者

`async function fn() {};`

在普通函数声明前加上async关键字，就是异步函数。



**async关键字**

1.普通函数定义前加async关键字，普通函数变成异步函数

2.异步函数默认返回 promise对象

3.在异步函数内部使用 return关键字进行结果返回,结果会被包裹的在promise对象中，return关键字代替了 resolve方法

4.在异步函数内部使用 throw关键字抛出程序异常

5.调用异步函数再链式调用then方法获取异步函数执行结果

6.调用异步函数再链式调用 catch方法获取异步函数执行的错误信息，也可以获取throw关键字抛出的错误信息



**await关键字**

1.await关键字只能出现在异步函数中

2.await后面只能写 promise对象写其他类型的API是不不可以的

3.await关键字可以暂停异步函数向下执行直到 promise返回结果，**不需要then方法了**



**util模块当中的promisify方法可以将API包装成promise对象**

![image-20200528184129440](/image-20200528184129440.png)



# 四.MongoDB数据库

## 1.概述

### 1.1为什么要使用数据库

- 动态网站中的数据都是存储在数据库中的
- 数据库可以用来持久存储客户端通过表单收集的用户信息
- 数据库软件本身可以对数据进行高效的管理



### 1.2什么是数据库

数据库即存储数据的仓库，可以将数据进行有序的分门别类的存储。它是独立于语言之外的软件，可以通过API去操作它

![image-20200521131436092](/image-20200521131436092.png)



### 1.3数据库相关概念

在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）

![image-20200521132658041](/image-20200521132658041.png)



## 2.Mongoose 第三方模块

npm install mongoose下载



### 2.1启动MongoDB

net stop mongodb 停止

net start mongodb 启动



### 2.2数据库连接

用mongoose提供的connect方法，**返回的是一个promise对象**

![image-20200521211503488](/image-20200521211503488.png)

![image-20200521213413019](/image-20200521213413019.png)



### 2.3创建数据库

用connect方法连接数据库时，如果数据库不存在，会自动创建



## 3.MongoDB增删改查操作

### 3.1创建集合

创建集合分为两步，一是对**集合设定规则**，二是**创建集合**，创建 mongoose. Schema构造函数的实例即可创建集合

![image-20200521214140600](/image-20200521214140600.png)

**第一个参数是集合名称，第二个参数是集合规则**



### 3.2创建文档

两种方法

![image-20200605162228697](/image-20200605162228697.png)



![image-20200522123639611](/image-20200522123639611.png)

MongoDB的API都是异步API，都可以使用promise的then和catch方法



### 3.3MongoDB数据库导入数据

mongoimport -d数据库名称  -c集合名称  --file要导入的数据文件（**这里是两个-**）



### 3.4查询文档

#### 3.4.1find方法

![image-20200522125441235](/image-20200522125441235.png)

`User.find({_id:'5c09f297aeb04b22f8460968'}).then(result=>console.log(result))`

括号面有条件按条件查找

**注意：不管有几个文档，都按数组的方式返回**



#### 3.4.2findOne方法

- 返回一条文档，默认返回当前集合中的第一条文档

- 也可以传递条件

- 返回的是一个对象



#### 3.4.3其他查询方法

1.匹配大于 小于

`User.find({age:{$gt:20,$lt:50}}).then(result=>console.log(result))`



2.匹配包含

`User.find({hobbies:{$in:['敲代码']}}).then(result=>console.log(result))`



3.选择要查询的字段

`User.find().select('name emali -_id').then(result=>console.log(result))`

如果不要查询哪一项，**在前面加-**

id是默认显示的



4.将数据按照年龄进行排序

`User.find().sort('age').then(result=>console.log(result))`

这里是升序，降序可以在字段前加-号



5.skip跳过多少条数据  limit限制查询数量

`User.find().skip(2).limit(2).then(result=>console.log(result))`



### 3.5删除文档

#### 3.5.1删除单个

`Course.findOneAndDelete({}).then(result=>console.log(result))`

查询到一条文档并删除，返回值是删除的文档



#### 3.5.2删除多个

`User.deleteMany({}).then(result=>console.log(result))`

返回值是一个对象{n:4,ok:1}

n代表删除了几条数据，ok代表操作是否成功



### 3.6更新文档

####  3.6.1更新单个

![image-20200522154646832](/image-20200522154646832.png)

返回值是一个对象

![image-20200522154811450](/image-20200522154811450.png)



#### 3.6.2更新多个

![image-20200522154830748](/image-20200522154830748.png)





### 3.7mongoose验证

在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败



-  require：true 必传字段
-  minlength: 3  字符串最小长度
-  maxlength: 10  字符串最大长度
-  trim: true   去除字符串两边空格

-  min: 3   数值最小值为3
-  max: 20  数值最大值为20
-  default：默认值    **如果没有传这个值，则系统默认传default中的值**
-  enum：['html','js','node.js']    传递的值必须在数组的范围内

![image-20200522215705309](/image-20200522215705309.png)

**第二种用法，属性为数组**

![image-20200522220458249](/image-20200522220458249.png)



- 还可以自定义验证规则

**validate：自定义验证器**

![image-20200522221615508](/image-20200522221615508.png)



### 3.8集合关联

通常**不同集合的数据之间是有关系的**，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联

![image-20200523164357805](/image-20200523164357805.png)

- 使用id对集合进行关联
- 使用populate方法进行关联集合查询

![image-20200523164626642](/image-20200523164626642.png)



## 4.增删改查案例

### 4.1querystring内置模块

querustring内置模块中有个parse方法可以将字符串转换为对象

![image-20200523220518509](/image-20200523220518509.png)

### 4.2 301重定向

res.writeHead中301代表重定向

![image-20200525220244211](/image-20200525220244211.png)



### 4.3 query

url内置模块将字符串解析为对象，里面的query属性包含了参数，默认是字符串，第二个参数为true，则为对象

![image-20200525230345804](/image-20200525230345804.png)





# 五、模板引擎

## 1.模板引擎的基础概念

### 1.1模板引擎

是node.js的第三方模块

可以让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更利于维护。



### 1.2art-template模板引擎

![image-20200526164823231](/image-20200526164823231.png)

代码示例

![image-20200526171041377](/image-20200526171041377.png)

在art文件中，**{{属性名}}**即可提取属性值



## 2.模板引擎语法

### 2.1模板语法

art-template同时支持两种模板语法：**标准语法**和**原始语法**。
标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力。

**标准语法：{{数据}}**

**原始语法：<%=数据%>**



### 2.2输出

- 如果是**数据变量**或者**数据**，会解析出数据变量的值
- 如果是表达式，会运算结果
- 但是不能解析标签（出于安全考虑）

代码示例：

![image-20200526173303291](/image-20200526173303291.png)

![image-20200526173320166](/image-20200526173320166.png)



### 2.3原文输出

数据中带标签，默认模板引擎不会解析标签，会将其转义后输出

如果要解析出标签：

**标准语法：{{@数据}}**

**原始语法：<%-数据%>**



### 2.4条件判断

在模板中可以根据条件来决定显示哪块HTML代码

![image-20200526234355726](/image-20200526234355726.png)



### 2.5循环

- **标准语法：{{each 数据}}   {{/each}}**
- **原始语法：<% for(){ %>   <%}>**

![image-20200526234749816](/image-20200526234749816.png)

这里$index 和 $value 分别代表循环目标的索引号和值



### 2.6子模板

使用子模板可以将网站公共区块（头部、底部）**抽离到单独的文件中**

**标准语法：{{include '模板'}}**

**原始方法:<% include('模板')%>**



### 2.7模板继承

使用模继承可以将网站HTML骨架单独抽取到单独的文件夹中，其他页面模板可以继承骨架文件

**{{extend '骨架'}} ** 继承骨架模板

**{{block 'head'}} {{/block}}**   在模板中挖坑，后续填充

**{{block 'head'}} 内容{{/block}}**    在继承的模板中填坑

代码示例：

骨架模板

![image-20200527003713210](/image-20200527003713210.png)

首页模板

![image-20200527003728529](/image-20200527003728529.png)

输出

![image-20200527003746585](/image-20200527003746585.png)



### 2.9模板配置

#### 2.9.1向模板中导入变量 

语法：

`template.defaults.imports.变量名 = 变量值;`

例：处理时间

![image-20200527164257504](/image-20200527164257504.png)

模板文件

![image-20200527164314990](/image-20200527164314990.png)

结果

![image-20200527164358332](/image-20200527164358332.png)



#### 2.9.2设置模板根目录

设置模板根目录

`template.defualts.root = 模板根目录;`

这样设置之后，用template来处理模板时，第一个参数写文件名就行了



#### 2.9.3设置模板的默认后缀

设置默认后缀

`template.defualts.extname = '.art';`

**注意这里如果不设置，默认是HTML文件**



## 3.学生档案信息案例

### 3.1router第三方模块创建路由

用于实现路由

使用步骤：

1.获取路由对象

`const getRouter = require('router');`

`const router = getRouter();`

2.调用路由对象提供的方法创建路由(创建/add路由)

`router.get('/add', (req ,res) => {`

​		`res.end();`

`)`

3.启用路由，是路由生效

`app.on('request' ,(req ,res) => {`

​		`router(req ,res，()=>{});`

`})`

**要注意的是这里第三个参数是回调函数，必须要填，不然会报错**

![image-20200527211736635](/image-20200527211736635.png)



### 3.2serve-static第三方模块实现静态资源访问服务

使用步骤：

1.引入serve-static模块获取创建静态资源服务功能的方法

`const serveStatic = require('serve-static');`

2.调用方法创建静态资源服务，并制定静态资源服务目录

`const serve = serveStatic('根目录');`

3.启用静态资源服务功能

`app.on('request',(req ,res) => {`

​		`serve(req ,res,()=>{});`

`});`

**注意：这里第三个参数也是必填的**





# 六.express框架

## 1.express框架框架简介

### 1.1express框架是什么

Express是一个基于Node平台的**web应用开发框架**，它提供了一系列的强大特性，帮助你**创建各种Web应用**

我们可以使用 npm install express命令进行下载



### 1.2express框架特性

- 提供了**方便简洁的路由定义方式**
- 对获取HTTP**请求参数**进行了**简化处理**
- 对**模板引擎支持程度高**，方便渲染动态HTM页面
- 提供了中**间件机制**有效**控制HTTP请求**（简单理解就是可以加控制阀）
- 拥有大量第三方中间件对功能进行扩展

代码示例：

![image-20200528171540862](/image-20200528171540862.png)

send方法不仅可以响应文本，还可以响应**对象**

**用express创建的服务器，可以直接获取请求参数**

![image-20200528173627852](/image-20200528173627852.png)



## 2.中间件

中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理

**简单的说，中间件就是水流中的阀门**

![image-20200528171829306](/image-20200528171829306.png)



### 2.1中间件的组成

中间件主要由两部分组成，**中间件方法**及**请求处理函数**

中间件方法由express提供，负责请求拦截，请求处理函数由开发人员提供，负责处理请求

`app.get('请求路径'，处理函数)`

app.get()就是中间件方法，处理函数就是请求处理函数

**同一个请求可以设置多个中间件，对同一个请求多次处理**，但默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配

**如果要匹配所有中间件，需要在上一个中间中调用next方法**

例：

`app.get('/request',(req , res , next)=> {`

​	`req.name = '张三'；`

​	`next();`

`})`

`app.get('/request',(req , res )=> {`

​	`console.log(req.name);`

`})`



### 2.2app.use 中间件

1.app.use可以匹配所有请求方式，不分get和post

`app.use((req , res , next)=> {`

​		`cosole.log(req.url)`

`})`



2.app.use第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收请求

`app.use('/admin' , (req , res , next) => {`

​	`console.log(req.url);`

​	`next();`

`})`



### 2.3中间件应用

1.做路由保护

客户端访问需要登录的页面时，未登录不能访问

2.网站维护公告

3.自定义404页面

![image-20200528175243310](/image-20200528175243310.png)

**注意：这里直接响应，会自动设置http状态码为200，需要用status()方法手动改写状态码**



### 2.4错误处理中间件

在程序执行过程中，不可避免的出现一些无法预料的错误，比如文件读取失败，数据库连接失败。

**错误处理中间件是用来集中处理错误的地方**

代码示例：

访问服务器出错

![image-20200528183356131](/image-20200528183356131.png)

这里错误信息存储在message属性中



读取文件出错

**这里读取文件是异步API，要将错误引出**

![image-20200528183842848](/image-20200528183842848.png)



### 2.5捕获错误(try catch)

- node.js中，**异步API**的错误信息都是通过**回调函数获取的**，**支持promise对象的异步API**还可以通过**catch()方法获取错误**
- **异步函数(async)**，用**try catch 语句**捕获错误
- try catch 语句可以捕获**异步函数**及其他**同步代码**执行过程中的错误，但不能捕获其他**API(回调函数)**的错误

代码示例：

![image-20200601185922555](/image-20200601185922555.png)



## 3.express请求处理

### 3.1构建模块化路由

通常一个项目中的路由非常多，通过构建模块化路由，将**路由进行分类**，**分别进行管理**

代码示例：

![image-20200528200541950](/image-20200528200541950.png)



项目中，分别将不同的路由功能放在不同的文件中，然后将各个路由引入app.js主文件中

![image-20200528203735712](/image-20200528203735712.png)



### 3.2GET请求参数获取

express框架中使用req.query即可获取GET参数，框架内部会将参数转换为对象并返回



### 3.3POST参数的获取

express框架中接收POST请求参数需要借助第三方包**body-parser**

方法：

`const bodyParser = require('body-parser');`

`app.use(bodyParser.urlencoded({extended: false}));`

`app.post('/', (req , res) => {`

​		`res.send(req.body);`

`})`

这里**extended：false**意思是使用node.js内置模块querystring来解析参数，

**extended：true** 意思是用第三方包qs来解析参数



### 3.4express路由参数

![image-20200528222838967](/image-20200528222838967.png)在访问路由时，可以设置路由参数，必须要输入这些参数才能访问到该路由

输入地址时**/：id**对应**/123**



### 3.5静态资源的处理

express内置的**express.static**方法可以方便的托管静态文件

`app.use(express.static('根目录'));`

注意这里的根目录需要**拼接为绝对路径**

![image-20200528224111263](/image-20200528224111263.png)



## 4.express-art-template模板引擎

### 4.1express-art- template

为了使art- template模板引擎能够更好的和 Express框架配合，模板引擎官方在原art- template模板引擎的基础上封装了 express-art- template

使用方法：

![image-20200529184640779](/image-20200529184640779.png)

render方法是express提供的方法，它会

- 自动设置模板路径
- 自动拼接模板后缀
- 自动响应内容给客户端

`render('模板文件',{数据});`



### 4.2app.locals对象

把变量设置到app.locals对象下面，这个**数据在所有的模板中都可以使用**

![image-20200529192433597](/image-20200529192433597.png)





# 七、blog案例

## 1.模板中的外链资源

1.路径不是相对于当前文件

2.是相对于**浏览器地址栏中的请求路径**

![image-20200605213608587](/image-20200605213608587.png)

这里浏览器把/admin当做请求路径，login当做请求文件



### 解决方案：

将相对路径改成绝对路径

![image-20200605213928960](/image-20200605213928960.png)

前面加斜杠就是绝对路径





## 2.密码加密 bcrypt

### 哈希加密

哈希加密是单程加密方式：1234 => abcd

只能加密，不能解密，在加密的密码中加入随机字符串，增加密码可被破解的难度

**方法：**

![image-20200608221141733](/image-20200608221141733.png)

**密码比对**

![image-20200608225815615](/image-20200608225815615.png)



bcrypt需要依赖其他环境，需下载一下三个模块

![image-20200608221410286](/image-20200608221410286.png)

**bcrypt装不上可以用bcryptjs代替**

![image-20200608233110993](/image-20200608233110993.png)





## 3.cookie和session

### 1.cookie

cookie：浏览器在电脑硬盘中开辟的块空间，主要供服务器端存储数据。

- cookie中的数据是以域名的形式进行区分的
- cookie中的数据是有过期时间的，超过时间数据会被浏览器自动删除
- cookie中的数据会随着请求被自动发送到服务器端



![image-20200608232516866](/image-20200608232516866.png)



### 2.session

session：实际上是一个对象，存储在服务器端的内存中，在session对象中也可以存储多条数据，**每一条都有一个sessionid作为唯一标识**



session的使用：

![image-20200609122700929](/image-20200609122700929.png)

![image-20200609122736364](/image-20200609122736364.png)



## 4.express框架中重定向用res.redirect



## 5.用户登出清除cookie和session

![image-20200609131443953](/image-20200609131443953.png)





## 6.Joi模块

是JavaScript对象的规则描述语言和验证器

![image-20200609160611838](/image-20200609160611838.png)

![image-20200609162542799](/image-20200609162542799.png)

**valid表示只能在值只能为规定的值**



## 7.查询数据库数据总数

![image-20200609204146348](/image-20200609204146348.png)



## 8.隐藏域

![image-20200610221040763](/image-20200610221040763.png)

隐藏域i一个type属性为hidden的input标签



## 9.formidable

![image-20200611121258965](/image-20200611121258965.png)



## 10.表单的enctype属性

属性值默认为application/x-www.form-urlencoded，

**如果涉及到文件上传，表单必须要有这个属性，值为multipart**



## 11.文件预览的另一种方法FileReader

![image-20200611130952363](/image-20200611130952363.png)



## 12.mongoose-sex-page模块进行数据分页

![image-20200611175306270](/image-20200611175306270.png)

page:要查询第几页数据

size:每页的数据条数

display:显示的页码数（最大）



返回值是一个对象

![image-20200611175456305](/image-20200611175456305.png)



## 13.mongoDB数据库添加账号

![image-20200611223349933](/image-20200611223349933.png)

![image-20200612115620743](/image-20200612115620743.png)

![image-20200611225031169](/image-20200611225031169.png)

这里的路径是MongoDB的**日志和数据**的路径





## 14.开发环境和生产环境

**什么是开发环境与生产环境**

环境，就是指项目运行的地方，当项目处于开发阶段，项目运行在**开发人员的电脑**上，项目所处的环境就是开发环境当项目开发完成以后，要将项目放到真实的网站服务器电脑中运行，项目所处的环境就是生产环境。

为什么要区分开发环境与生产环境

因为在不同的环境中，项目的配置是不一样的，需要在项目代码中判断当前项目运行的环境，根据不同的环境应用不同的项目配置



**通过电脑系统中的环境变量来区分当前环境是开发环境还是生产环境**

![image-20200611230212817](/image-20200611230212817.png)

### process.env.NODE_ENV来获取环境变量

process对象是locals对象下的一个属性值





## 15.morgan模块

morgan模块可以在处于开发环境时，将用户发送的请求信息打印在控制台中

![image-20200612122147405](/image-20200612122147405.png)



## 16.config模块

作用：允许开发人员将不同运行环境下的应用配置信息抽离到单独的文件中，模块内部自动判断当前应用的运行环境，并读取对应的配置信息，极大提供应用配置信息的维护成本，避免了当运行环境重复的多次切换时，手动到项目代码中修改配置信息

![image-20200611230839641](/image-20200611230839641.png)



**可以将敏感配置信息放置在系统环境变量中，通过系统环境变量来提取敏感信息**

![image-20200612123757301](/image-20200612123757301.png)